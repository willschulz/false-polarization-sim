<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Self-Censorship Multi-Stage Visualization</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background-color: #fafafa; margin: 0; padding: 0; }
  .controls { padding: 1rem; background: #ffffff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 0.5rem; }
  .control-group { margin-bottom: 0.5rem; }
  label { font-size: 0.9rem; font-weight: bold; }
  input[type=range] { width: 200px; }
  button { padding: 0.4rem 0.8rem; margin-right: 0.5rem; font-size: 0.9rem; }
  #canvasContainer { display: flex; justify-content: center; }
</style>
</head>
<body>
<div class="controls">
  <div class="control-group">
    <label>Number of issues per user: <span id="issuesVal4">20</span></label><br>
    <input id="issuesSlider4" type="range" min="3" max="50" step="1" value="20">
  </div>
  <div class="control-group">
    <label>User-level filtering effect (β₁): <span id="beta1Val4">0.015</span></label><br>
    <input id="beta1Slider4" type="range" min="0" max="0.05" step="0.001" value="0.014">
  </div>
  <div class="control-group">
    <label>Issue-level filtering effect (β₂): <span id="beta2Val4">0.005</span></label><br>
    <input id="beta2Slider4" type="range" min="0" max="0.02" step="0.0005" value="0.0045">
  </div>

  <div class="control-group">
    <button id="sampleBtn4">Sample</button>
    <button id="autoBtn4">Start Auto Sample</button>
    <button id="resetBtn4">Reset</button>
  </div>
  <div style="font-size:0.85rem; color:#555;">Four stages show how filtering shapes visible and invisible attitudes. Squares represent users’ true means. If a user posts at least one issue, their square also drops to the second stage (posting users). Posted and unposted attitudes for that user then appear as circles falling to the third and fourth stages. Issue-level circles emanate from the user’s bar in the posting-user panel and are colored according to whether the attitude becomes visible (posted) or remains hidden (shadow).</div>
</div>
<div id="canvasContainer"></div>
<script>
let nIssues4 = 20;
// Default coefficients correspond roughly to the mixed linear probability model
// estimated in the static analysis. beta04 is the constant term; beta14
// multiplies the average extremity of other issues; beta24 multiplies the
// extremity of the current issue. These values can be adjusted via the
// sliders for beta1 and beta2.
let beta14 = 0.01455;
let beta24 = 0.004542;
const beta04 = -0.004686;
// Standard deviations for random intercepts and issue-level variation
const sdUser  = 0.011565;
const sdTopic = 0.003447;
const sdIssue = 0.7;
const sdUserMu = 1.0;
let autoSampling4 = false;
let autoInterval4;
// Default interval for auto sampling (in milliseconds).  A smaller value
// speeds up the automatic generation of users when auto sampling is active.
let autoSpeed4 = 300;

// Ball class for animated elements
class Ball {
  constructor(x, y, targetX, targetY, shape, color, value, histTarget) {
    this.x = x;
    this.y = y;
    this.targetX = targetX;
    this.targetY = targetY;
    this.shape = shape; // 'square' or 'circle'
    this.color = color;
    this.value = value;
    this.histTarget = histTarget;
    this.landed = false;
    this.size = 8;
    // Optional pending issues data for user-level squares. When this exists,
    // additional circles will be spawned from the posting-users panel after
    // the square lands.
    this.pendingIssues = null; // array of {val, isPosted}
    this.pendingBinIdx = null;
    this.trueMean = null;
    this.issuesProcessed = false;
  }
  update() {
    const speed = 4;
    if (!this.landed) {
      this.y += speed;
      // ease x toward target
      this.x += (this.targetX - this.x) * 0.05;
      if (this.y >= this.targetY) {
        this.y = this.targetY;
        this.landed = true;
        if (this.histTarget) {
          addValueToHistogram4(this.histTarget, this.value);
        }
        // If this ball has pending issues and hasn't yet spawned them,
        // generate the issue-level circles now. Only process once.
        if (this.pendingIssues && !this.issuesProcessed) {
          this.issuesProcessed = true;
          // Starting bar for this user's mean in the posting-users panel
          const binPixelW = width / histConfig4.nBins;
          const barStartX = this.pendingBinIdx * binPixelW;
          // For each issue, create a circle falling to panel 3 or 4
          for (const obj of this.pendingIssues) {
            const startX = barStartX + Math.random() * binPixelW;
            const startY = histConfig4.panels[1].baseY;
            const targetX = mapValueToX4(obj.val);
            const targetY = obj.isPosted ? histConfig4.panels[2].baseY : histConfig4.panels[3].baseY;
            const col = obj.isPosted ? color(220, 0, 0) : color(128, 128, 128);
            const histKey = obj.isPosted ? 'postedAttitudes' : 'shadowAttitudes';
            balls4.push(new Ball(startX, startY, targetX, targetY, 'circle', col, obj.val, histKey));
          }
        }
      }
    }
  }
  draw() {
    noStroke();
    fill(this.color);
    if (this.shape === 'square') {
      rectMode(CENTER);
      rect(this.x, this.y, this.size, this.size);
    } else {
      circle(this.x, this.y, this.size);
    }
  }
}

// Histogram containers for each stage
const hist4 = {
  trueAll: { counts: [] },
  truePosting: { counts: [] },
  postedAttitudes: { counts: [] },
  shadowAttitudes: { counts: [] }
};
const histConfig4 = {
  nBins: 20,
  // Define a broader range to visualize ideology distributions on a wider scale.
  // Range of values shown on the x-axis. We use a symmetric window around zero
  // spanning six units in each direction so the panels maintain a consistent scale.
  range: [-6, 6],
  panels: []
};
let balls4 = [];

function setup() {
  const canvasW = 700;
  const canvasH = 800;
  const canvas = createCanvas(canvasW, canvasH);
  canvas.parent('canvasContainer');
  // Initialize histogram counts
  initHist4(hist4.trueAll);
  initHist4(hist4.truePosting);
  initHist4(hist4.postedAttitudes);
  initHist4(hist4.shadowAttitudes);
  // Populate the top panel with a static normal distribution. We sample many
  // user means from N(0,1) and accumulate them into the trueAll histogram.
  populateTrueAllStatic(2000);
  // Define panel base positions (bottom of each histogram)
  const panelHeight = canvasH / 4;
  histConfig4.panels = [
    { baseY: panelHeight - 50 },
    { baseY: 2 * panelHeight - 50 },
    { baseY: 3 * panelHeight - 50 },
    { baseY: 4 * panelHeight - 50 }
  ];
  textAlign(CENTER, CENTER);
  textSize(12);
}

// Populate the trueAll histogram with a static sample from N(0,1).
function populateTrueAllStatic(nSamples) {
  // Clear existing counts
  hist4.trueAll.counts = new Array(histConfig4.nBins).fill(0);
  const [min, max] = histConfig4.range;
  const binWidth = (max - min) / histConfig4.nBins;
  // For each sample, draw a user latent center mu and a set of nIssues4 issues around it.
  for (let i = 0; i < nSamples; i++) {
    const mu = randomGaussian(0, sdUserMu);
    let sum = 0;
    for (let j = 0; j < nIssues4; j++) {
      const iv = randomGaussian(mu, sdIssue);
      sum += iv;
    }
    const trueMean = sum / nIssues4;
    if (trueMean < min || trueMean >= max) continue;
    const idx = Math.floor((trueMean - min) / binWidth);
    if (idx >= 0 && idx < hist4.trueAll.counts.length) {
      hist4.trueAll.counts[idx]++;
    }
  }
}

function initHist4(obj) {
  obj.counts = new Array(histConfig4.nBins).fill(0);
}

function addValueToHistogram4(which, value) {
  const h = hist4[which];
  const [min, max] = histConfig4.range;
  if (value < min || value >= max) return;
  const binWidth = (max - min) / histConfig4.nBins;
  const idx = Math.floor((value - min) / binWidth);
  if (idx >= 0 && idx < h.counts.length) {
    h.counts[idx]++;
  }
}

function drawHistogram4(which, panelIdx) {
  const h = hist4[which];
  const panel = histConfig4.panels[panelIdx];
  const baseY = panel.baseY;
  const barMaxHeight = 80;
  const maxCount = Math.max(...h.counts, 1);
  const binPixelW = width / histConfig4.nBins;
    // Ensure histogram bars use CORNER mode so the y coordinate refers to the baseline.
    rectMode(CORNER);
    for (let i = 0; i < h.counts.length; i++) {
      const barH = (h.counts[i] / maxCount) * barMaxHeight;
      const x = i * binPixelW;
      let col;
    if (which === 'trueAll') col = color(0, 128, 0, 180);          // green for true distribution
    else if (which === 'truePosting') col = color(0, 102, 204, 180); // blue for posting users
    else if (which === 'postedAttitudes') col = color(220, 0, 0, 180); // red for visible attitudes
    else col = color(128, 128, 128, 180);                       // gray for shadow attitudes
      noStroke();
      fill(col);
      // Draw the bar so that its base aligns exactly on baseY. Using a negative
      // height draws the bar upward from the baseline.
      rect(x, baseY, binPixelW - 1, -barH);
    }
  // Draw baseline and label
  stroke(0);
  line(0, baseY, width, baseY);
  noStroke();
  fill(0);
  let label;
  if (which === 'trueAll') label = 'All users: true means';
  else if (which === 'truePosting') label = 'Posting users: true means';
  else if (which === 'postedAttitudes') label = 'Visible attitudes (posted)';
  else label = 'Shadow attitudes (unposted)';
  text(label, width / 2, baseY + 20);
}

function draw() {
  background(250);
  // Draw horizontal dividers
  const ph = height / 4;
  stroke(230);
  line(0, ph, width, ph);
  line(0, 2 * ph, width, 2 * ph);
  line(0, 3 * ph, width, 3 * ph);
  // Update and draw balls
  for (let i = balls4.length - 1; i >= 0; i--) {
    const b = balls4[i];
    b.update();
    b.draw();
    if (b.landed) {
      balls4.splice(i, 1);
    }
  }
  // Draw static density in the top panel and histograms for lower panels.
  drawNormalDensity4(0);
  drawHistogram4('truePosting', 1);
  drawHistogram4('postedAttitudes', 2);
  drawHistogram4('shadowAttitudes', 3);
  // Overlay standard deviation markers (center and ±1, ±2) on all panels
  for (let i = 0; i < 4; i++) {
    drawStdMarkers4(i);
  }
}

// Draw a filled standard normal density curve on the specified panel. The
// density is scaled to the same maximum height used for histograms (80
// pixels). This ensures the static top panel remains on the same
// vertical scale as the histogram panels below. The distribution is
// defined over histConfig4.range, which is symmetric around zero.
function drawNormalDensity4(panelIdx) {
  const panel = histConfig4.panels[panelIdx];
  const baseY = panel.baseY;
  const barMaxHeight = 80;
  const [min, max] = histConfig4.range;
  // Precompute density values across a fine grid. We use 200 points for
  // smoothness. We compute the standard normal pdf and then scale it so
  // that the maximum density maps to barMaxHeight.
  const nPoints = 200;
  let maxPdf = 0;
  const xs = new Array(nPoints);
  const pdfVals = new Array(nPoints);
  for (let i = 0; i < nPoints; i++) {
    const x = min + (max - min) * (i / (nPoints - 1));
    // Standard normal pdf
    const pdf = (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * x * x);
    xs[i] = x;
    pdfVals[i] = pdf;
    if (pdf > maxPdf) maxPdf = pdf;
  }
  // Draw the filled shape. We map each x value to a canvas x coordinate
  // using mapValueToX4, and each pdf value to a height relative to
  // barMaxHeight. We build a path from left to right, then back along
  // the baseline to create a closed shape for fill().
  noStroke();
  fill(0, 128, 0, 180); // green with transparency to match top panel color
  beginShape();
  for (let i = 0; i < nPoints; i++) {
    const cx = mapValueToX4(xs[i]);
    const cy = baseY - (pdfVals[i] / maxPdf) * barMaxHeight;
    vertex(cx, cy);
  }
  // Close the shape by returning along the baseline from right to left
  for (let i = nPoints - 1; i >= 0; i--) {
    const cx = mapValueToX4(xs[i]);
    vertex(cx, baseY);
  }
  endShape(CLOSE);
  // Draw baseline and label
  stroke(0);
  line(0, baseY, width, baseY);
  noStroke();
  fill(0);
  text('All users: true means', width / 2, baseY + 20);
}

// Draw vertical lines indicating the center (0) and ±1 and ±2 standard
// deviations on the specified panel. These markers help the viewer
// interpret the distributions. Lines are drawn from the baseline up to
// barMaxHeight. Labels are not included to reduce clutter.
function drawStdMarkers4(panelIdx) {
  const panel = histConfig4.panels[panelIdx];
  const baseY = panel.baseY;
  const barMaxHeight = 80;
  // Coordinates for 0, ±1 and ±2
  const markers = [0, -1, 1, -2, 2];
  stroke(150);
  strokeWeight(1);
  for (const m of markers) {
    // Only draw markers within the visible range
    if (m >= histConfig4.range[0] && m <= histConfig4.range[1]) {
      const x = mapValueToX4(m);
      line(x, baseY, x, baseY - barMaxHeight);
    }
  }
  // Reset stroke weight for other drawings
  strokeWeight(1);
}

function mapValueToX4(val) {
  const [min, max] = histConfig4.range;
  const clamped = constrain(val, min, max);
  const frac = (clamped - min) / (max - min);
  return frac * width;
}

function sampleUser4() {
  // Sample the user's latent center (mu) from N(0, sdUserMu)
  const mu = randomGaussian(0, sdUserMu);
  // Sample issue-level attitudes around mu from N(mu, sdIssue)
  const issues = [];
  const absIssues = [];
  let sumAbs = 0;
  for (let i = 0; i < nIssues4; i++) {
    const iv = randomGaussian(mu, sdIssue);
    issues.push(iv);
    const a = Math.abs(iv);
    absIssues.push(a);
    sumAbs += a;
  }
  // Compute the user's true mean across issues
  const trueMean = issues.reduce((a, b) => a + b, 0) / nIssues4;
  // Sample a random intercept for the user
  const u_user = randomGaussian(0, sdUser);
  // Compute per-issue posting probabilities using the linear probability model.
  const pIssues = [];
  for (let i = 0; i < nIssues4; i++) {
    const abs_i = absIssues[i];
    const otherExt = (nIssues4 > 1) ? (sumAbs - abs_i) / (nIssues4 - 1) : 0;
    // Sample a topic-level intercept for this issue
    const v_topic = randomGaussian(0, sdTopic);
    let eta = beta04 + beta14 * otherExt + beta24 * abs_i + u_user + v_topic;
    // Clamp to [0,1] to obtain a probability
    const p_i = constrain(eta, 0, 1);
    pIssues.push(p_i);
  }
  // Determine if the user posts at least one issue
  let prodNot = 1;
  for (let i = 0; i < pIssues.length; i++) {
    prodNot *= (1 - pIssues[i]);
  }
  const pUserPost = 1 - prodNot;
  const posts = Math.random() < pUserPost;
  if (!posts) {
    // User does not post any issues: no squares drop from the top. We simply return.
    return;
  }
  // Prepare pending issues array with posted/unposted flags
  const pendingIssues = [];
  for (let i = 0; i < nIssues4; i++) {
    const isPosted = Math.random() < pIssues[i];
    pendingIssues.push({ val: issues[i], isPosted: isPosted });
  }
  // Determine the bin index for the user's true mean to locate its bar in the top histogram
  const [min, max] = histConfig4.range;
  const binWidthVal = (max - min) / histConfig4.nBins;
  let binIdx = Math.floor((trueMean - min) / binWidthVal);
  if (binIdx < 0) binIdx = 0;
  if (binIdx >= histConfig4.nBins) binIdx = histConfig4.nBins - 1;
  const binPixelW = width / histConfig4.nBins;
  const barStartX = binIdx * binPixelW;
  const startX = barStartX + Math.random() * binPixelW;
  // Target x for the square is the same as its starting x so it falls straight down
  const targetX = startX;
  // Create a square that drops from the top panel into the posting-users panel.
  const userBall = new Ball(startX,
                            histConfig4.panels[0].baseY,
                            targetX,
                            histConfig4.panels[1].baseY,
                            'square',
                            color(0, 102, 204),
                            trueMean,
                            'truePosting');
  userBall.pendingIssues = pendingIssues;
  userBall.pendingBinIdx = binIdx;
  userBall.trueMean = trueMean;
  balls4.push(userBall);
}

// Event listeners
const issuesSliderEl4 = document.getElementById('issuesSlider4');
const beta1SliderEl4 = document.getElementById('beta1Slider4');
const beta2SliderEl4 = document.getElementById('beta2Slider4');
const issuesValEl4 = document.getElementById('issuesVal4');
const beta1ValEl4 = document.getElementById('beta1Val4');
const beta2ValEl4 = document.getElementById('beta2Val4');
issuesSliderEl4.addEventListener('input', () => {
  nIssues4 = parseInt(issuesSliderEl4.value);
  issuesValEl4.textContent = nIssues4;
  // Whenever the number of issues changes, recompute the static top distribution
  populateTrueAllStatic(2000);
});
beta1SliderEl4.addEventListener('input', () => { beta14 = parseFloat(beta1SliderEl4.value); beta1ValEl4.textContent = beta14.toFixed(3); });
beta2SliderEl4.addEventListener('input', () => { beta24 = parseFloat(beta2SliderEl4.value); beta2ValEl4.textContent = beta24.toFixed(3); });

document.getElementById('sampleBtn4').addEventListener('click', () => { sampleUser4(); });
document.getElementById('resetBtn4').addEventListener('click', () => {
  initHist4(hist4.trueAll);
  initHist4(hist4.truePosting);
  initHist4(hist4.postedAttitudes);
  initHist4(hist4.shadowAttitudes);
  balls4 = [];
  // Recompute the static distribution after a reset so it reflects the current nIssues4
  populateTrueAllStatic(2000);
});
document.getElementById('autoBtn4').addEventListener('click', (e) => {
  if (!autoSampling4) {
    autoSampling4 = true;
    autoInterval4 = setInterval(() => sampleUser4(), autoSpeed4);
    e.target.textContent = 'Stop Auto Sample';
  } else {
    autoSampling4 = false;
    clearInterval(autoInterval4);
    e.target.textContent = 'Start Auto Sample';
  }
});
</script>
</body>
</html>
